## Introduction au s√©minaire

::: notes
Expos√© propos√© pour l'action _"Les lyc√©ens √† la fac"_ du salon des √©tudes sup√©rieures du 29 juillet 2022 de l'UNC (13h, Amphi A400).
:::

---

### Pr√©sentation personnelle

#### Formation

- 2004 : Ing√©nieur Informatique/DEA, INSA de Lyon
- 2008 : Doctorat Informatique, INSA de Lyon

#### Emplois

- 2008-2010 : postdoc INRIA Grenoble
- 2010-2022 : ma√Ætre de conf√©rences en informatique
  - 2010-2020 : Universit√© Claude Bernard Lyon 1
  - 2020-2022 : Universit√© de la Nouvelle-Cal√©donie

#### Th√©matiques

- bases de donn√©es, s√©curit√©, science des donn√©es

---

#### Avant-propos

**Clause de non-responsabilit√©** : ni philosophe, ni sociologue, ni d√©veloppeur : _enseignant-chercheur **en informatique**_.

::: notes

Beaucoup de m√©tiers en informatique, j'en parle, mais on va centrer sur _la science_

:::

---

### Les informaticiens d√©testent-ils les imprimantes ?

![[r/ProgrammerHumor -- I can fix it, but not because I'm a programmer](https://www.reddit.com/r/MemeTemplatesOfficial/comments/sk7nmt/will_smith_shouting_calm_shouting/)](img/printer_programmer.png)

:::notes

blague : l'imprimante est un decalopode capricieux, qui comme le poulpe, une fois au pied du mur jette de l'encre sur ses aggresseurs et se vexe en bourrant le papier

:::

---

#### Pourquoi les informaticiens d√©testent-ils les imprimantes ?

- il faut se d√©placer pour tester ?
- c'est [salissant](https://www.reddit.com/r/CatastrophicFailure/comments/8flfri/toner_explosion/) ?
- il y a des humains, g√©n√©ralement irrit√©s de la situation ?
- les pilotes sont ferm√©s ? (voir [The Story of Open Source](https://amogh.medium.com/the-story-of-open-source-so-far-bfcb685d85a4))

. . .

Ce n'est pas le m√©tier **d'un d√©veloppeur** (ni celui d'un _architecte logiciel_, d'un _int√©grateur_, d'un _testeur_, d'un _administrateur r√©seaux_ etc).

. . .

Ce n'est pas non plus le m√©tier **d'un enseignant-chercheur**.

::: notes

Les grosses **questions** :

- quels sont ces m√©tiers ?
- qu'est ce qui les diff√©rencie ?

s√©parer l'utilisateur du concepteur va nous amener, retrospectivement √† s√©parer le du d√©veloppeur/concepteur du chercheur/scientifique
:::

---

Quels sont **ces m√©tiers**, qu'est ce qui _les diff√©rencie_ ?

. . .

Une partie de la r√©ponse est : _la science informatique_.

---

### Objectifs de la conf√©rence

- rompre certaines **id√©es re√ßues** sur l'informatique et ses m√©tiers
- positionner la **science informatique** dans le champ technique et scientifique
- **motiver les contenus** des formations universitaires en informatique

::: notes

Pour la formation, √† l'UNC ou ailleurs, ce n'est pas tr√®s diff√©rent

:::

---

## L'informatique : science, technique ou art ?

![[Amazon -- The Art Of Computer Programming](https://images-na.ssl-images-amazon.com/images/I/410vJZbAZGS._SY393_BO1,204,203,200_.jpg)](img/taoc.jpg)

---

### M√©taphore du couteau

Un parall√®le entre _utiliser_, _r√©aliser_ et _penser_ un couteau en acier et un programme informatique.

---

#### Utiliser un couteau - l'art

![[medium.com -- How To Use Kitchen Knives ](https://medium.com/@alyarb03/how-to-use-kitchen-knives-safety-tips-5f073a98a18b)](img/using-knife-safely.jpeg)

---

#### Fabriquer un couteau - la technique

![[Industrial Heating -- Forging Knives in College](https://www.industrialheating.com/articles/95969-forging-knives-in-college)](img/forging-blade.jpg)

---

#### Fabriquer un acier - la science

![Par Cdang ‚Äî Travail personnel, CC BY-SA 3.0, <https://commons.wikimedia.org/w/index.php?curid=5827078>](img/Diag_binaire_aciers_et_structure.png)

::: notes

L'acier a √©t√© d√©couvert tr√®s t√¥t dans l'histoire car sa mati√®re premi√®re est abondante (minerai), et qu‚Äôil est facile √† travailler. L'acier ¬´ de base ¬ª est de fait peu on√©reux.

    fer : moins de 0,008 % de carbone en masse
    acier : entre 0,008 et 2,11 % de carbone ;
    fonte : teneur sup√©rieure √† 2,11 %.

Diagramme binaire fer-carbone et structure cristalline des aciers √† l'√©tat recuit
:::

---

#### Parall√®le

|               | _Acier_                           | _Informatique_               |
| ------------- | --------------------------------- | ---------------------------- |
| **Art**       | cuisinier                         | utilisateur                  |
| **Technique** | artisan forgeron                  | d√©veloppeur                  |
|               | ing√©nieur m√©ttalurgiste           | ing√©nieur informaticien      |
| **Science**   | physico-chimiste, cristallographe | scientifique en informatique |

::: notes

- Une question de **recul** : les _utilisateurs_ d'un langage de programmation **sont** des _d√©veloppeurs_.
- La _cr√©ation n'est pas descendante mais faite de va-et-vient_ : les besoins des d√©veloppeurs am√®nent √† (re)penser les langages de programmations.
  - dans bcp de process sci, dont les maths
  - pas de sots m√©tiers !
- Acier/dev : un parall√®le assez naturel, car on parle de forge, de craftmanship dans le domaine du d√©veloppement

:::

---

### Une d√©finition de la science informatique (1/2)

<!-- #### Informatics -->

> **Informatics** is the scientific discipline that underpins the digital world.

[Informatics Reference Framework for School](https://www.informaticsforall.org/the-informatics-reference-framework-for-school-release-february-2022/).

NDA : _informatics_ synonyme de _computer science_.

---

### Une d√©finition de la science informatique (2/2)

> L‚Äôinformatique parle d‚Äôobjets de diff√©rente nature : **informations**, **langages**, **machines** et **algorithmes**.

[La place de l'informatique dans la classification des sciences, Gilles DOWEK, 2014](https://www.lemonde.fr/blog/binaire/2014/02/05/la-place-de-linformatique-dans-la-classification-des-sciences/)

::: notes

Chacun de ces quatre concepts est _ant√©rieur √† l‚Äôinformatique_, mais ce qui ce que l‚Äôinformatique apporte sans doute de nouveaux est _leur organisation en une science coh√©rente_.

:::

---

## Le probl√®me `min-max`

**Probl√®me** trouver _le plus grand_ √©l√©ment **et** _le plus petit_ √©l√©ment d'une collection lin√©aire (par exemple : liste, tableau) _non-vide_ d'entiers naturels.

---

### Diff√©rentes solutions

#### Solution _√©tudiant_

```python
def min_max_etudiant(arr):
    the_min = arr[0]
    the_max = arr[0]
    for v in arr:
        if v < the_min:
            the_min = v
        if v > the_max:
            the_max = v

    return the_min, the_max

min_max_etudiant([1, 42, 3, 2, 0, 5]) #renvoie (0, 42)
```

. . .

_C'est une solution classique et correcte une s√©quence d'op√©rations √©l√©mentaires, au plus proche de l'algorithmique_.

::: notes

- arr est non-vide, on prend le premier
- classique et correcte **MAIS** un dev de doit jamais √©crire √ßa !

:::

---

#### Solution _d√©veloppeur_

```python
def min_max_sorter(arr):
    s = sorted(arr)
    # s[0] le premier √©l√©ment apr√®s le tri
    # s[-1] le dernier √©l√©ment apr√®s le tri
    return s[0], s[-1]
```

. . .

_C'est une solution correcte, o√π le d√©veloppeur utilise une fonction de tri qu'il sait disponible dans √† peu pr√®s tous les langages (ici Python)_.

::: notes
mais... il y a un mais !
:::

---

#### Solution _Pythonista_

```python
def min_max_pythonista(arr):
    return min(arr), max(arr)
```

. . .

_C'est une solution correcte aussi, o√π le d√©veloppeur connait bien le langage Python et propose une solution "Pythonique"_.

::: notes

:::

---

### Quelle est la meilleure solution ?

#### D√©finir **meilleure**

. . .

- la plus _efficace en temps_ ?
- la plus _efficace en m√©moire_ ?
- la plus _√©l√©gante_, la plus _lisible_ ?
- la plus rapide _√† programmer_ ?

. . .

On va ici √©valuer _l'efficacit√© **en temps**_

---

#### Crit√®res d'efficacit√© en temps

. . .

Comment avoir une **√©valuation robuste** des trois solutions ?

. . .

Comment faire des **pr√©dictions** quant-√† leurs comportements selon la taille des donn√©es ?

::: notes

Robuste : (ind√©pendantes des contigences mat√©rielles), voir du mod√®le de calcul

Ne pas sous-estimer/oublier que g√©n√©ralement on a pas besoin de performance !

Si on fait la somme du temps d'exec plus du temps de dev, Python est plus rapide que le C car on code beaucoup plus rapidement des t√¢ches complexes

Pour l'√©valuation empirique des performances **sur quelle machine, quel OS, quelle version de Python, quel jeu de donn√©es ?**

:::

---

#### √âvaluation empirique (1/2)

![](code/min_max_small.png)

**Peut-on d√©terminer quelle est la meilleure solution ?**

::: notes

Pas vraiment

On voit au passage que l'ordre n'est pas le m√™me et qu'il y a de la variance.

Une autre exec ne donnera pas le m√™me r√©sultat

:::

---

#### √âvaluation empirique (2/2)

![](code/min_max_large.png)

**Peut-on d√©terminer quelle est la meilleure solution ?**

---

### La compl√©xit√© algorithmique

- peut-on **mod√©liser** les comportements de ces algorithmes ?
  - **Oui** avec l'√©valuation (asymptotique) de la complexit√© (au pire cas) en fonction de la taille de l'entr√©e
- peut-on **comparer** leurs comportements ?
  - **Oui, en partie** en comparant leur complexit√©
- peut-on **pr√©dire** le temps d'ex√©cution ?
  - **Non**, car on est d√©pendants de facteurs inconnus **et** des entr√©es

::: notes
comportements = allure des courbes

:::

---

- Que **compter** ?
  - le nombre comparaisons entre entiers
- Combien de **comparaisons** sont effectu√©es ?
  - pour `min_max_etudiant` : _oui_
  - pour `min_max_sorted` : il faut `min` et `max`
    - mais on les imagine facilement
  - pour `min_max_pythonista` : il faut `sorted`
    - et l√†, c'est un peu plus compliqu√©...
    - ...voir [le code source de `CPython`](https://github.com/python/cpython/blob/main/Objects/listsort.txt)
    - mais on conna√Æt les algorithmes

---

### Mod√©lisation de `min_max_etudiant`

```python
def min_max_etudiant(arr):
    # soit n la longueur de la s√©quence, n = len(arr)
    the_min = arr[0]
    the_max = arr[0]
    for v in arr: # on passe (n-1) fois dans cette boucle
        # une comparaison ici
        if v < the_min:
            the_min = v
        # une autre comparaison l√†
        if v > the_max:
            the_max = v
    return the_min, the_max
```

Pour une entr√©e de longueur $n$, on effectue $2 \times (n-1)$ comparaison

. . .

Ce qui compte, c'est **l'ordre de grandeur**, ici, proportionnel √† $n$

---

### Comparaison des compl√©xit√©s

En utilisant la notation de Landau, dite _grand O_ :

Soient $f,g : \mathbb{N} \to \mathbb{R}^+$ deux applications, on dit que _f est domin√©e par g_ (en $+\infty$) que l'on note $f(n) = O (g(x))$ lorsqu'il existe un rang $N \in \mathbb{N}$ et une constante $C \in \mathbb{R}^+$ tels que $\forall n > N, f(n) \leq C g(x)$.

---

| notation      | compl√©xit√©    | exemple                         |
| ------------- | ------------- | ------------------------------- |
| $O(1)$        | constante     | acc√®s √† un √©l√©ment              |
| $O(log(n))$   | logarithmique | recherche dichotomique          |
| $O(n)$        | lin√©aire      | recherche üëà                    |
| $O(n.log(n))$ |               | "bon" tri                       |
| $O(n^2)$      | quadratique   | "mauvais" tri                   |
| $O(n^c)$      | polynomiale   | produit de matrice na√Øf ($c=3$) |
| $O(c^n)$      | exponentielle | voyageur de commerce            |

---

### Comparaison des compl√©xit√©s des solutions `min-max`

- `min_max_etudiant` est en $O(n)$
- `min_max_pythonista` est en $O(n)$ √©galement
- `min_max_sorted` est en $O(n.log(n))$
  - c'est **moins bon** : on r√©soud un probl√®me trop compliqu√© par rapport au besoin !

. . .

Ceci explique/confirme les allures des courbes !

::: notes

- Tout est √† un coefficient pr√®s
- Rien n'est dit sur les constantes, clairement celle de pythonista est meilleure que celle de √©tudiant
- Optimiser, c'est changer la constante mais **surtout** changer les ordres de grandeurs
- Une notion de frugalit√© ?

:::

---

## La formation en informatique

Science **et** technique **et** art

. . .

- _science_ : ce qui est **vrai**
- _technique_ : ce qui est **faisable**
- _art_ : ce qui est **beau**

---

![[SourabhSKatoch](https://twitter.com/sourabhskatoch/status/1279426987744849923)](img/ML_IA_VS_MATHS.jpg)

---

### Programmes

Sciences et techniques (et art) se d√©clinent :

- _langages_
  - paradigmes de programmation, d√©veloppement, compilation
- _algorithmes_
  - structures de donn√©es, th√©orie de la compl√©xit√©, d√©cidabilit√©, mod√®les de calculs
- _informations_ et _machines_
  - codage/repr√©sentation, r√©seau, syst√®me, informatique embarqu√©e

---

#### Exemple

<https://unc.nc/formations/licence-informatique/>

---

## R√©f√©rences

- [√âpist√©mologie de l'informatique, WIKIPEDIA](https://fr.wikipedia.org/wiki/%C3%89pist%C3%A9mologie_de_l%27informatique)
- [Pourquoi et comment le monde devient num√©rique, G√©rard BERRY, le√ßon inaugurale au coll√®ge de France, 2008](https://www.college-de-france.fr/site/gerard-berry/inaugural-lecture-2008-01-17-18h00.htm)
- <https://www.reddit.com/r/ProgrammerHumor/>

[Notebook Python](code/minmax.ipynb)
